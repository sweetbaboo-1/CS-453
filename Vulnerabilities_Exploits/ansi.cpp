#include <iostream>
#include <string>
#include <iomanip>

using namespace std;

/*************************************
 * For an ANSI-Unicode conversion vulnerability to exist in the code, the following 
 *  must be present:
 *  1. There must be a buffer where the basetype is greater than one.
 *  2. Validation of the buffer must check the size of the buffer rather than the 
 *      number of elements in the buffer.
 ****************************************/
void ansiVulnerability(short userInput[])
{
	short unicodeText[256];

	for (int i = 0; i < sizeof(unicodeText); i++)
	{
		unicodeText[i] = userInput[i];
	}

// 	for (int i = 0; i < (sizeof(unicodeText) / sizeof(unicodeText[0])); i++)
// 	{
// 		cout << "index = " << i << " " << unicodeText[i] << endl;
// 	}
}

/**************************************
 * ansi WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
	short workingArray[256] = {500, 345, 234};
	workingArray[250] = 69;
	ansiVulnerability(workingArray);
}

/**************************************
 * For an ANSI-Unicode conversion vulnerability to be exploited, the attacker must 
*  do the following:
*  1. The attacker must provide more than half as much data into the 
*  outwardly facing buffer as it is designed to hold.
*  2. From here, a variety of injection attacks are possible. The most likely 
*  candidates are stack smashing or heap smashing. In the above example, 
*  the third parameter of the copyUnicodeText() function is the number 
*  of elements in the string (256 elements), not the size of the string (512 
*  bytes). The end result is a buffer overrun of 256 bytes
 *************************************/
void ansiExploit()
{
	short exploitArray[1024];

	for (int i = 0; i < (sizeof(exploitArray) / sizeof(exploitArray[0])); i++)
	{
		exploitArray[i] = i;
	}
	ansiVulnerability(exploitArray);
}

int ansiMain()
{
	ansiWorking();
	ansiExploit();

	return 0;
}