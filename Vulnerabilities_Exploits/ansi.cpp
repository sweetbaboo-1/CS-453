#include <iostream>
#include <string>
#include <iomanip>

using namespace std;

/*************************************
 * For an ANSI-Unicode conversion vulnerability to exist in the code, the following 
 *  must be present:
 *  1. There must be a buffer where the basetype is greater than one.
 *  2. Validation of the buffer must check the size of the buffer rather than the 
 *      number of elements in the buffer.
 ****************************************/
void ansiVulnerability(char userInput[])
{
	short unicodeText1[256];
	short unicodeText2[256];

	for (int i = 0; i < sizeof(unicodeText1); i++)
	{
		cout << "i = " << i << " " << unicodeText1[i] << endl;
	}

	// for (int i = 0; i < sizeof(unicodeText1); i++)
	// {

	// }
}

/**************************************
 * ansi WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
	char workingArray[256] = {'w', 'e', 'd'};
	ansiVulnerability(workingArray);
}

/**************************************
 * For an ANSI-Unicode conversion vulnerability to be exploited, the attacker must 
*  do the following:
*  1. The attacker must provide more than half as much data into the 
*  outwardly facing buffer as it is designed to hold.
*  2. From here, a variety of injection attacks are possible. The most likely 
*  candidates are stack smashing or heap smashing. In the above example, 
*  the third parameter of the copyUnicodeText() function is the number 
*  of elements in the string (256 elements), not the size of the string (512 
*  bytes). The end result is a buffer overrun of 256 bytes
 *************************************/
void ansiExploit()
{
	// ansiVulnerability();
}

int ansiMain()
{
	ansiWorking();
	ansiExploit();

	return 0;
}