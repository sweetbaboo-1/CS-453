#include <iostream>
#include <string>
#include <iomanip>

using namespace std;

/*************************************
 * For an ANSI-Unicode conversion vulnerability to exist in the code, the following 
 *  must be present:
 *  1. There must be a buffer where the basetype is greater than one.
 *  2. Validation of the buffer must check the size of the buffer rather than the 
 *      number of elements in the buffer.
 ****************************************/
inline void ansiVulnerability(short userInput[])
{
	short unicodeText[32];
	//The size of command will read a larger value than the physical number of cells in the array. This causes the vulnerability to occur 
	// short is 2 bytes each, this means that the size of function will read 64 instead of 32 thus causing an overflow. 
	for (int i = 0; i < sizeof(unicodeText); i++)
	{
		unicodeText[i] = userInput[i];
	}

	// Display working ansi
	if (userInput[0] == 4)
	{
		for (int i = 0; i < (sizeof(unicodeText) / sizeof(unicodeText[0])); i++)
		{
			cout << "unicodeText[" << i << "] = " << unicodeText[i] << endl;
		}
	}

	// Display exploit asni
	else
	{
		for (int i = 0; i < sizeof(unicodeText); i++)
		{
			cout << "unicodeText[" << i << "] = " << unicodeText[i] << endl;
		}
	}
}

/**************************************
 * ansi WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
inline void ansiWorking()
{
	// A non malicious array of data to be copied into unicode array
	short workingArray[32] = {4, 6, 7, 24, 235, 2356, 3, 235, 745};
	ansiVulnerability(workingArray);
	cout << "\nThe array that is copied into the unicodeText array doesn't do anything malicious\n"
		 << "becuase it only has 9 items in it. They are correctly copied over to the new array\n"
		 << "without any problems.\n";
}

/**************************************
 * For an ANSI-Unicode conversion vulnerability to be exploited, the attacker must 
*  do the following:
*  1. The attacker must provide more than half as much data into the 
*  outwardly facing buffer as it is designed to hold.
*  2. From here, a variety of injection attacks are possible. The most likely 
*  candidates are stack smashing or heap smashing. In the above example, 
*  the third parameter of the copyUnicodeText() function is the number 
*  of elements in the string (256 elements), not the size of the string (512 
*  bytes). The end result is a buffer overrun of 256 bytes
 *************************************/
inline void ansiExploit()
{
	// Malicious array with more data than that unicode array is allotted to hold
	short exploitArray[64];

	// Fill the array with data
	for (int i = 0; i < (sizeof(exploitArray) / sizeof(exploitArray[0])); i++)
	{
		exploitArray[i] = i;
	}

	ansiVulnerability(exploitArray);
	cout << "\nThe malicious array that is passed into ansiVulnerability has 64 items, as opposed\n"
		 << "to the unicodeText array that only has 32. Since the for loop is checking for the size of\n"
		 << "the array instead of the number of elements, the for look will go way past the allotted memory\n"
		 << "for the unicode array.\n";
}

inline int ansiMain()
{
	bool keepRunning = true;
	string userInput = "";

	while (keepRunning)
	{
		cout << "\n1. Working Input"
			 << "\n2. Malicous Input"
			 << "\nQ. Exit\n";
		cin >> userInput;

		if (userInput == "1")
			ansiWorking();
		else if (userInput == "2")
			ansiExploit();
		else if (userInput == "q" || userInput == "Q") // exit
		{
			cout << "Thank you, goodbye\n";
			keepRunning = false;
		}
		else
			cout << "Please enter a valid option\n";
	}

	return 0;
}