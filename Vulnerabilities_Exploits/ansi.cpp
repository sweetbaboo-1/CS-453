#include <iostream>
#include <string>
#include <iomanip>

using namespace std;

/*************************************
 * For an ANSI-Unicode conversion vulnerability to exist in the code, the following 
 *  must be present:
 *  1. There must be a buffer where the basetype is greater than one.
 *  2. Validation of the buffer must check the size of the buffer rather than the 
 *      number of elements in the buffer.
 ****************************************/
inline void ansiVulnerability(short userInput[])
{
	short unicodeText[32];

	for (int i = 0; i < sizeof(unicodeText); i++)
	{
		unicodeText[i] = userInput[i];
	}

	if (userInput[0] == 4)
	{
		for (int i = 0; i < (sizeof(unicodeText) / sizeof(unicodeText[0])); i++)
		{
			cout << "unicodeText[" << i << "] = " << unicodeText[i] << endl;
		}
	}
	else
	{
		for (int i = 0; i < sizeof(unicodeText); i++)
		{
			cout << "unicodeText[" << i << "] = " << unicodeText[i] << endl;
		}
	}
}

/**************************************
 * ansi WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
inline void ansiWorking()
{
	short workingArray[32] = {4, 6, 7, 24, 235, 2356, 3, 235, 745};
	ansiVulnerability(workingArray);
}

/**************************************
 * For an ANSI-Unicode conversion vulnerability to be exploited, the attacker must 
*  do the following:
*  1. The attacker must provide more than half as much data into the 
*  outwardly facing buffer as it is designed to hold.
*  2. From here, a variety of injection attacks are possible. The most likely 
*  candidates are stack smashing or heap smashing. In the above example, 
*  the third parameter of the copyUnicodeText() function is the number 
*  of elements in the string (256 elements), not the size of the string (512 
*  bytes). The end result is a buffer overrun of 256 bytes
 *************************************/
inline void ansiExploit()
{
	short exploitArray[64];

	for (int i = 0; i < (sizeof(exploitArray) / sizeof(exploitArray[0])); i++)
	{
		exploitArray[i] = i;
	}
	ansiVulnerability(exploitArray);
}

inline int ansiMain()
{
	bool keepRunning = true;
	string userInput = "";

	while (keepRunning)
	{
		cout << "\n1. Working Input"
			 << "\n2. Malicous Input"
			 << "\nQ. Exit\n";
		cin >> userInput;

		if (userInput == "1")
			ansiWorking();
		else if (userInput == "2")
			ansiExploit();
		else if (userInput == "q" || userInput == "Q") // exit
		{
			cout << "Thank you, goodbye\n";
			keepRunning = false;
		}
		else
			cout << "Please enter a valid option\n";
	}

	return 0;
}